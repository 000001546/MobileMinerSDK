//
// Created by Mr.Kuang on 10/27/16.
// 第五章－指针与数组
//

/* 1. 指针是一种保存变量地址的变量。

   在 C 语言中,指针的使用非常广泛,原因之一是,指 针常常是表达某个计算的惟一途径,
   另一个原因是,同其它方法比较起来,使用指针通常可 以生成更高效、更紧凑的代码。

   指针与数组之间的关系十分密切。

   指针与地址：
   通常的机器都有一系列连续的编号或编址的存储单元，这些存储单元可以单个操作，也可以以连续
   成组的方式进行操作。

   通常情况下，机器的一个字节可以存放一个char类型的数据，两个相邻的字节存储单元可以存储一个short
   类型的数据，四个相邻的字节存储单元可以存储一个long型的数据，指针是能够存放一个地址的一组存储单元
   (通常是两个或 4 个字节)。

   一元运算符&可用于取一个对象的地址,因此,下列语句:
   p = &c;

   将把 c 的地址赋值给变量 p,我们称 p 为“指向”c 的指针。

   地址运算符&只能作用于内存中的对象，即变量与数组元素。它不能作用于表达式，常量，register类型的变量。
*/


/*
    2. 一元运算符*是间接寻址或间接引用运算符。当它作用于指针时,将访问指针所指向的对 象。我们在这里假定 x 与 y 是整数,而 ip 是指向 int 类型的指针,下面的代码段说明了如 何在程序中声明指针以及如何使用运算符&和*:
       int x = 1, y = 2, z[10];
       int *ip; //ip is a pointer to int

       int x = 1, y = 2, z[10];
       int *p = &x;
       y = *p;
       printf("%1d \n", y);
       *p = 0;
       printf("%1d \n", x);
       *p = &z[0];

       变量 x、y 与 z 的声明方式我们已经在前面的章节中见到过。我们来看指针 ip 的声明,
       如下所示: int *ip;
       这样声明是为了便于记忆。该声明语句表明表达式*ip 的结果是 int 类型。这种声明变量的 语法与声明该变量所在表达式的语法类似。同样的原因,对函数的声明也可以采用这种方式。 例如,声明
       double *dp,atof(char *);
       表明,在表达式中,*dp 和 atof(s)的值都是 double 类型,且 atof 的参数是一个指向 char
       类型的指针。
       我们应该注意,指针只能指向某种特定类型的对象,也就是说,每个指针都必须指向某 种特定的数据类型。(一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针, 但它不能间接引用其自身。我们将在 5.11 节中详细讨论该问题)。
       如果指针 ip 指向整型变量,那么在 x 可以出现的任何上下文中都可以使用*ip,因此, 语句
       *ip = *ip + 10; 将把*ip 的值增加 10。
       一元运算符*和&的优先级比算术运算符的优先级高,因此,赋值语句
       y = *ip + 1
       将把*ip 指向的对象的值取出并加 1,然后再将结果赋值给 y,而下列赋值语句:
       *ip += 1
       则将 ip 指向的对象的值加 1,它等同于
       ++*ip
       或
       语句的执行结果。语句(*ip)++中的圆括号是必需的,否则,该表达式将对 ip 进行加 1 运算, 而不是对 ip 指向的对象进行加 1 运算,这是因为,类似于*和++这样的一元运算符遵循从右 至左的结合顺序。
       最后说明一点,由于指针也是变量,所以在程序中可以直接使用,而不必通过间接引用 的方法使用。例如,如果 iq 是另一个指向整型的指针,那么语句
       iq = ip
       将把 ip 中的值拷贝到 iq 中,这样,指针 iq 也将指向 ip 指向的对象。
*/



/* 3. 指针与函数

   由于 C 语言是以传值的方式将参数值传递给被调用函数。因此,被调用函数不能直接修 改主调函数中变最的值。例如,排序函数可能会使用一个名为 swap 的函数来交换两个次序颠 倒的元素。但是,如果将 swap 函数定义为下列形式:
   void swap(int x, int y)  {
   int temp;
         temp = x;
         x = y;
         y = temp;
   }
   则下列语句无法达到该目的。
   swap(a, b);
   这是因为,由于参数传递采用传值方式,因此上述的 swap 函数不会影响到调用它的例程中的
   参数 a 和 b 的值。该函数仅仅交换了 a 和 b 的副本的值。


   // 这样才能实现交换
   void swap(int *p, int *q) {
       int temp = *p;
       *p = *q;
       *q = temp;
   }
*/


/* 4. 指针与数组

   在 C 语言中,指针和数组之间的关系十分密切,因此,在接下来的部分中,我们将同时 讨论指针与数组。
   通过数组下标所能完成的任何操作都可以通过指针来实现。
   一般来说,用指针编写的程序比用数组下标编写的程序执行速度快,
   但另一方面,用指针实现的程序理解起来稍微困难一些。


   数组的元素存储是连续的，第一个元素的地址就是数组的指针，即数组的名字，数组的名字就是数组第一个元素的地址。

   int a[10];
   int *p = &a[0];
   那么p和a就


   无论数组 a 中元素的类型或数组长度是什么,上面的结论都成立。“指针加 1”就意味着,
    pa+1 指向 pa 所指向的对象的下一个对象。相应地,pa+i 指向 pa 所指向的对象之后的第 i 个对象。
   下标和指针运算之间具有密切的对应关系。根据定义,数组类型的变量或表达式的值是
   该数组第 0 个元素的地址。执行赋值语句
   pa = &a[0];
   后,pa 和 a 具有相同的值。因为数组名所代表的就是该数组最开始的一个元素的地址,所以,
   赋值语句 pa=&a[0]也可以写成下列形式: pa = a;

   对数组元素的a[i]的引用就可以写成 *(a + i)
   在计算数组元素a[i］的值时，c语言实际上是先将a[i]转换成 * (a + i)的形式，然后再进行求值。

   &a[i]等价于 a + i;

   a + i是a之后第i个元素。

   pa[i]与 * （pa + i)等价。

   但是,我们必须记住,数组名和指针之间有一个不同之处，指针是一个变量，因此在c语言中，pa = a与 pa ++
   都是合法的。但是数组名不是变量，所以 a = pa，a++是非法的。

   当把数组名传给函数的时候，实际上是把数组第一个元素的地址传递过去。
   在被调用函 数中,该参数是一个局部变量,因此,数组名参数必须是一个指针,也就是一个存储地址值 的变量。

   可以利用该特性编写 strlen 函数的另一个版本,该函数用于计算一个字符串 的长度。


   === 在形式参数中，char s[]与 char *s是等价的，我们一般喜欢用后者，因为它比前者更直观地表明了该参数是一个 指针。

   如果将数组名传递给函数,函数可以根据情况判定是按照数组处理还是按照指针处理, 随后根据相应的方式操作该参数。
*/



/* 5. 地址算数运算符。

   如果 p 是一个指向数组中某个元素的指针,那么 p++将对 p 进行自增运算并指向下一个 元素,
   而 p+=i 将对 p 进行加 i 的增量运算,使其指向指针 p 当前所指向的元素之后的第 i 个元素。
   这类运算是指针或地址算术运算中最简单的形式。
*/


/*
   6. 字符指针与函数。

   字符串常量是一个数组，例如：
   "I am a string"

   在字符串内部的表示中，字符数组是以空字符 \0结尾的。,程序可以通过检查空字符找到字符数组的结尾。
   字符串常量占据的存储单元数也因此比双引号内的字符数大 1。

   下面两个定义有很大的差别：
   char message[] = "I am a string; // 定义一个数组
   char *pmessage = "I am a string"; // 定义一个指针

   message 是一个仅仅足以存放初始化字符串以及空字符'\0'的一维数组。
   pmessage 是一个指针，其值指向一个字符串常量。


   // 将t的值赋给s
   void strcpy1(char *s, char *t) {
       int i = 0;

       while ((s[i] = t[i]) != '\0') {
           i++;
       }
   }

   // 将t的值赋给s，利用指针
   void strcpy2(char *s, char *t) {
       while ((*s++ = *t++) != '\0') {
           ;
       }
   }
*/



/*
   7. 指针数组以及指向指针的指针。

   由于指针本身也是变量，所以它们也可以像其他变量那样存放在数组中。

   在该例子中,指针数组 1ineptr 的声明是新出现的重要概念:
   char *lineptr[MAXLINES];
   它表示 1ineptr 是一个具有 MAXLINES 个元素的一维数组,其中数组的每个元素是一个指 向字符类型对象的指针。也就是说,lineptr[i]是一个字符指针,而*lineptr[i]是该指 针指向的第 i 个文本行的首字符。
   由于 1ineptr 本身是一个数组名,因此,可按照前面例子中相同的方法将其作为指针使 用,这样,writelines 函数可以改写为:
   void writelines(char *lineptr[], int nlines) {
   while (nlines-- > 0) printf("%s\n", *lineptr++);
   }
   (注意这里的数组变量 lineptr 可以改变值)
*/


/*  8.指针数组的初始化

    char *month_name(int n)
    {
    static char *name[] = {
    "Illegal month",
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
    };
    }

    其中,name 的声明与排序例子中 lineptr 的声明相同,是一个一维数组,数组的元素为字 符指针。
    name 数组的初始化通过一个字符串列表实现,列表中的每个字符串赋值给数组相应 位置的元素。
    第 i 个字符串的所有字符存储在存储器中的某个位置,指向它的指针存储在 name[i]中。
    由于上述声明中没有指明 name 的长度,因此,编译器编译时将对初值个数进 行统计,
    并将这一准确数字填入数组的长度
*/


#include <stdio.h>

void swap(int *p, int *q);
int strLen(char *s);
void strcpy1(char *s, char *t);
void strcpy2(char *s, char *t);

main() {
    int x = 1, y = 2, z[10];
    int *p = &x;
    y = *p;
    printf("%1d \n", y);
    *p = 0;
    printf("%1d \n", x);

    swap(&x, &y);

    printf("x:%1d, y:%1d \n", x, y);

    printf("str len: %d \n", strLen("hello world"));

    char s[4];
    char *t = "test";

    strcpy2(s, t);

    printf("cpy: %s \n", s);
    printf("len: %d \n", strLen(s));
    return 0;
}

// 这样才能实现交换
void swap(int *p, int *q) {
    int temp = *p;
    *p = *q;
    *q = temp;
}

// 因为 s 是一个指针,所以对其执行自增运算是合法的。执行 s++运算不会影响到
// strlen 函 数的调用者中的字符串,它仅对该指针在 strlen 函数中的私有副本进行自增运算。
// 因此, 类似于下面这样的函数调用:
// strlen("hello,world");
// strlen(array);
// strlen(ptr);
// 都可以正确地执行
int strLen(char *s) {
    int n = 0;
    for (; *s != '\0'; s++) {
        n++;
    }

    return n;
}

// 将t的值赋给s
void strcpy1(char *s, char *t) {
    int i = 0;

    while ((s[i] = t[i]) != '\0') {
        i++;
    }
}

// 将t的值赋给s，利用指针
void strcpy2(char *s, char *t) {
    while ((*s++ = *t++) != '\0') {
        ;
    }
}
