//
// Created by Mr.Kuang on 10/26/16.
// 第二章－类型，运算符，表达式
//

/* 1.变量的命名规则：由字母，数字组成，'_' 被看成字母, 区分字母大小写，一般变量用小写，符号常量用大写。*/

/* 2.C语言只提供给下面几种数据类型：
   char 字符型，占用一个字节，可以存放本地字符集中的一个字符
   int  整型，通常反映了所用机器中整数的最自然长度
   float 单精度浮点型
   double 双精度浮点型

   * 就是这四种，此外还可以在这些基本数据类型前面加上一些限定符。short和long是两个限定整形的限定符。
   short int sh, long int counter, 在上面声明中，int可以省略。比如short sh, long counter;
   int类型可以为16位或32位，short为16位，long为32位。
   short 与 long 两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数。
   int通常代表特定机器中整数的自然长度。short类型通常为16位,1ong类型通常为32位,
   int类型可以为16位或32位。各编译器可以根据硬件特性自主选择合适的类型长度,
   但要遵循下列限制:short与int类型至少为16位,而long类型至少为32位,并且short类型不得长于int类型,
   而int类型不得长于long类型。

   * 类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。
   unsigned限定的值总是正数或者0，如果 char 对象占用 8位,那么 unsigned char 类型变量的取值范围为 0~255，
   signed char 类型变量的取值范围则为-128~127(在采用对二的补码的机器上)。
   不带限定符的 char 类型对象 是否带符号则取决于具体机器,但可打印字符总是正值

   * long double 类型表示高精度的浮点数。同整型一样, 浮点型的长度也取决于具体的实现。
   float、double 与 long double 类型可以表示相同的长度,也可以表示两种或三种不 同的长度 */


/* 3.常量。
   类似于1234的整数常量属于int型，long类型的常量一般以l或者L结尾，如123456L。
   如果一个整数太大以至于无法用 int 类型表示时,也将被当作 long 类型处理。

   无符号常量以字母u或者U结尾。后缀为ul或者UL表明为unsigned long类型。

   浮点数常量中包含一个小数点(如123.4)或一个指数(如 1e-2), 也可以两者都有。
   没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型,
   而后缀 l 或 L 则表 示 long double 类型。浮点数如果不带f或者F，那么就是double类型，
   后缀为l或者L，则表示long double型。

   整数型除了可以用十进制表示，还可以用八进制或者十六进制表示。带前缀 0 的整型常量表示它为八进制形式，
   带前缀为 0x 或者 0X 的表示它为十六进制。

   例如十进制的31可以写成八进制的037，也可以写成十六进制的0x1f, 0x1F。

   八进制与十六进制的常量也可 以使用后缀 L 表示 long 类型,使用后缀 U 表示 unsigned 类型。
   例如OXFUL，unsigned long 十六进制，表示十进制的15。
*/



/* 4.ANSI C语言中的全部转义字符序列如下所示:
     \a响铃符 \b回退符 \f换页符 \n换行符 \r 回车符
     \t 横向制表符 \v 纵向制表符
     \\反斜杠 \?问号 \'单引号 \"双引号 \ooo 八进制数 \xhh 十六进制数


   字符常量'\0'表示值为 0 的字符,也就是空字符(null)。我们通常用'\0'的形式代替 0,
   以强调某些表达式的字符属性,但其数字值为 0。
*/



/* 5.从技术角度看,字符串常量就是字符数组。字符串的内部表示使用一个空字符'\0'作为串的结尾,因此。
   存储字符串的物理存储单元数比括在双引号中的字符数多一个。这种表示方法也说明, C语言对字符串的长度没有限制,
   但程序必须扫描完整个字符串后才能确定字符串的长度。

   标准库函数 strlen(s)可以返回字符串参数 s 的长度,但长度不包括末尾的'\0'。 下面是我们设计的 strlen 函数的一个版本:
   int strlen(char s[]) {
   int i;
   while (s[i] != '\0') {
    ++i;
   }
   return i;
   }
*/



/* 6. 枚举常量

   枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表,例如:enum boolean { NO, YES };
   在没有显式说明的情况下,enum 类型中第一个枚举名的值为 0,第二个为 1,依此类推。如 果只指定了部分枚举名的值,
   那么未指定值的枚举名的值将依着最后一个指定值向后递增, 参看下面两个例子中的第二个例子:
   enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t', NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };
   enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
   JUL, AUG, SEP, OCT, NOV, DEC };
   // FEB 的值为 2,MAR 的值为 3,依此类推
   不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。
*/



/* 7. 任何变量的声明都可以使用const限定符来限定。该限定符限定指定的变量的值不能修改。对数组而言，const
   限定符指定数组所有元素的值都不能被修改。

   const double e = 2.71828182845905;
   const char msg[] = "hello";

   const限定符也可以配合数组参数一起使用，它表示函数不能修改数组元素的值。
   如：int strLen(const char msg[]);
*/


/* 8. 算数运算符。
   二元算术运算符包括:+、-、*、/、%(取模运算符)。整数除法会截断结果中的小数部分。
   x % y 的结果是 x 除以 y 的余数,当 x 能被 y 整除时,其值为 0。

   取模运算 % 不能应用于 float 和 double型。

   二元运算符+和-具有相同的优先级,它们的优先级比运算符*、/和%的优先级低,而运 算符*、/和%的优先级又比
   一元运算符+和-的优先级低。算术运算符采用从左到右的结合规则。

   在c语言中，1为真，0为假。
*/


/*
   9. 类型转换。
   一般来说,自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数,并且不丢失信息的转换, 例如,在计算表达式 f+i 时,
   将整型变量 i 的值自动转换为浮点型(这里 的变量 f 为浮点型)。

   针对可能导致信息丢失的表达式,编译器可能会给出警告信息,比如把较长的整型值赋给较短的整型变量,
   把浮点型值赋值给整型变量,等等,但这些表达式并不非法。

   表达式中 float 类型的操作数不会自动转换为 double 类型,这一点与最初的定 义有所不同。
   一般来说,数学函数(如标准头文件<math.h>中定义的函数)使用双精度类型的变量。
   使用float类型主要是为了在使用较大的数组时节省存储空间,有时也为了节省机器执行时间(双精度算术运算特别费时)。
*/


/* 10. 按位运算符。

   C 语言提供了6个位操作运算符，这些运算符只能作用于于整型操作数，即只能作用于带符号或者无符号的char, int ,short, long
   类型。

   & 按位与(AND)
   | 按位或(OR)
   ^ 按位异或(XOR)
   <<左移
   >>右移
   ~ 按位取反(一元运算符)
*/


/* 11. 进制转换。

   @see http://jingyan.baidu.com/article/495ba84109665338b30ede98.html

   十进制，二进制，八进制，十六进制之间的转换。

   ** 十进制转二进制：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。
   如150-
   150 / 2 = 75 余 0
   75 / 2 = 37 余 1
   37 / 2 = 18 余 1
   18 / 2 = 9 余 0
   9 ／2 ＝ 4 余 1
   4 / 2 = 2 余 0
   2 / 2 = 1 余 0
   1 / 2 = 0 余 1

   除到值为0为止。然后从下往上拼余数 10010110




   ** 二进制转十进制: 把二进制数按权展开、相加即得十进制数。
   如 1       0       0        1      0       1      1     0
     1*2(7)  0*2(6)   0*2(5)   1*2(4)  0*2(3)  1*2(2)  1*2   0*2(0)

     相加 = 150



   ** 二进制转八进制：3位二进制数按权展开相加得到1位八进制数。
   （注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。

   0     1    0                0      1      0          1     1    0
   0＊2(2)+1*2(1)+0*2(0)    0＊2(2)+1*2(1)+0*2(0)   1＊2(2)+1*2(1)+0*2(0)

         2                            2                       6

   得到八进制为: 226





   ** 八进制转成二进制: 八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最右边补零
    如 226
    2
    2/2 = 1...0
    1/2 = 0 ..1
    // 不足补0
    010


    2
    2/2 = 1...0
    1/2 = 0 ..1
    // 不足补0
    010

    6
    6/2 = 3..0
    3/2 = 1..1
    1/2 = 0..1
    110

    二进制：10010110





    ** 二进制与十六进制之间的转换: 与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。
    （注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。
*/






/* 12. & 在c语言中有三种作用。
   * 取地址，单目运算符。
   int i, *p;
   p = &i;//这里的&作用是取变量i的地址。

   * 位操作中的与操作运算符
   也就是常说的and操作，双目运算符。
   二进制由0和1组成，两个二进制对应位上的值得都为1时为1，否则该值为0.

   如0x12&0x23 转为 二进制：
   B00010010
       &
   B00100011

   B00000010 = 0x02



   * 当两个&&一起用的时候，表示为逻辑运算中的与运算。
   逻辑运算结果只有0和1两种结果。
   一般在&&两边是两个逻辑表达式。
   当两个表达式值均为1时，&&运算结果为1，否则为0。
   比如
   2>1 && 0<1 这个的值为1&&1 = 1。
   1>2 && 2>0 这个值为0&&1 = 0。
   1>2 && 2>3 这个值为0&&0=0。
*/



/* 13. 左移就是把一个数的所有位都向左移动若干位,在C中用<<运算符.例如:

       int i = 1;

       i = i << 2; //把i里的值左移2位

       也就是说,1的2进制是000...0001(这里1前面0的个数和int的位数有关,32位机器,gcc里有31个0),
       左移2位之后变成 000...0100,也就是10进制的4,所以说左移1位相当于乘以2,那么左移n位就是乘以2的n次方了
       (有符号数不完全适用,因为左移有可能导致符号变化,下面解释原因)

       需要注意的一个问题是int类型最左端的符号位和移位移出去的情况.我们知道,int是有符号的整形数,最左端的1位是符号位,即0正1负,那么移位的时候就会出现溢出,例如:

       int i = 0x40000000; //16进制的40000000,为2进制的01000000...0000

       i = i << 1;

       那么,i在左移1位之后就会变成0x80000000,也就是2进制的100000...0000,符号位被置1,
       其他位全是0,变成了int类型所能表示的最小值,32位的int这个值是-2147483648,溢出.
       如果再接着把i左移1位会出现什么情况呢?在C语言中采用了丢弃最高位的处理方法,丢弃了1之后,i的值变成了0.

       左移里一个比较特殊的情况是当左移的位数超过该数值类型的最大位数时,编译器会用左移的位数去模类型的最大位数,
       然后按余数进行移位,如:

       int i = 1, j = 0x80000000; //设int为32位

       i = i << 33; // 33 % 32 = 1 左移1位,i变成2

       j = j << 33; // 33 % 32 = 1 左移1位,j变成0,最高位被丢弃

       在用gcc编译这段程序的时候编译器会给出一个warning,说左移位数>=类型长度.那么实际上i,
       j移动的就是1位,也就是33%32后的余数.在gcc下是这个规则,别的编译器是不是都一样现在还不清楚.

       总之左移就是: 丢弃最高位,0补最低位

       再说右移,明白了左移的道理,那么右移就比较好理解了.

       右移的概念和左移相反,就是往右边挪动若干位,运算符是>>.

       右移对符号位的处理和左移不同,对于有符号整数来说,比如int类型,右移会保持符号位不变,例如:

       int i = 0x80000000;

       i = i >> 1; //i的值不会变成0x40000000,而会变成0xc0000000

       就是说,符号位向右移动后,正数的话补0,负数补1,也就是汇编语言中的算术右移.
       同样当移动的位数超过类型的长度时,会取余数,然后移动余数个位.

       负数10100110 >>5(假设字长为8位)，则得到的是 11111101

       总之,在C中,左移是逻辑/算术左移(两者完全相同),右移是算术右移,会保持符号位不变.
       实际应用中可以根据情况用左/右移做快速的乘/除运算,这样会比循环效率高很多.
   */



/** 14. 按位或运算符(|)
        按位或运算将两个运算分量的对应位按位遵照以下规则进行计算：

         0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1

        即只要有1个是1的位，结果为1，否则为0。


        例如，023 | 035 结果为037。
        按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成：
         j = 017|j
 */


 /* 15. 按位异或运算符(^)
      按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算：

      0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0

      即相应位的值相同的，结果为 0，不相同的结果为 1。


      例如，013^035结果为026。
      异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。
      如欲求整型变量j的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，
      结果是0,原来为0的位，结果是1。
 */


 /* 16. 按位取反运算符(~)

     按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。
     例如, ~7的结果为0xfff8。
     取反运算常用来生成与系统实现无关的常数。如要将变量x最低6位置成0，其余位不变，可用代码x = x & ~077实现。
     以上代码与整数x用2个字节还是用4个字节实现无关。
     当两个长度不同的数据进行位运算时(例如long型数据与int型数据)，将两个运算分量的右端对齐进行位运算。
     如果短的数为正数，高位用0补满；如果短的数为负数，高位用1补满。如果短的为无符号整数，则高位总是用0补满。
     位运算用来对位串信息进行运算，得到位串信息结果。如以下代码能取下整型变量k的位串信息的最右边为1的信息位：((k-1)^k) & k。
 */