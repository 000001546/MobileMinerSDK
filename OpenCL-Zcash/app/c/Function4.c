//
// Created by Mr.Kuang on 10/26/16.
// 第四章－函数
//

/*
  1. 函数的概念，作用域。
*/



/*
  2. 头文件


    下面我们来考虑把上述的计算器程序分割到若干个源文件中的情况。如果该程序的各组 成部分很长,这么做还是有必要的。
    我们这样分割:将主函数 main 单独放在文件 main.c 中;将 push 与 pop 函数以及它们使用的外部变量放在第二个文件
    stack.c 中;将 getop 函数放在第三个文件 getop.c 中;将 getch 与 ungetch 函数放在第四个文件 getch.c 中。
    之所以分割成多个文件,主要是考虑在实际的程序中,它们分别来自于单独编译的库。
    此外,还必须考虑定义和声明在这些文件之间的共享问题。我们尽可能把共享的部分集 中在一起,
    这样就只需要一个副本,改进程序时也容易保证程序的正确性。我们把这些公共 部分放在头文件 calc.h 中,
    在需要使用该头文件时通过#include 指令将它包含进来 (#include 指令将在 4.11 节中介绍)


    ………………就是把公共的部分放在头文件中，然后在要用的.c或者.cpp中，#include头文件就可以用了。



    我们对下面两个因素进行了折衷:一方面是我们期望每个文件只能访问它完成任务所需 的信息;
    另一方面是现实中维护较多的头文件比较困难。我们可以得出这样一个结论:对于 某些中等规模的程序,
    最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要 使用更多的头文件,我们需要精心地组织它们。
*/




/*
   3. 静态变量。

   某些变量，比如文件stack.c中定义的变量sp与var以及文件 getch.c 中定义的变 量 buf 与 bufp，
   它们仅供其所在的源文件中的函数使用，其它函数不能访问。用 static 声明限定外部变量与函数,
   可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。

   通过 static 限定外部对象,可以达到隐藏外部对象的目的,比如,getch-ungetch 复合 结构需要共享
   buf 与 bufp 两个变量,这样 buf 与 bufp 必须是外部变量,但这两个对象不 应该被 getch 与 ungetch
   函数的调用者所访问。


   外部的 static 声明通常多用于变量,当然,它也可用于声明函数。通常情况下,函数 名字是全局可访问的,
   对整个程序的各个部分而言都可见。但是,如果把函数声明为 static 类型,则该函数名除了对该函数声明所在的文件可见外,其它文件都无法访问。
   static 也可用于声明内部变量。static 类型的内部变量同自动变量一样,是某个特定 函数的局部变量,
   只能在该函数中使用,但它与自动变量不同的是,不管其所在函数是否被 调用,它一直存在,
   而不像自动变量那样,随着所在函数的被调用和退出而存在和消失。换 句话说,
   static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变 量。



   简单点：
   当一个进程的全局变量被声明为static之后，它的中文名叫静态全局变量。
   静态全局变量和其他的全局变量的存储地点并没有区别，都是在.data段（已初始化）或者.bss段（未初始化）内，
   但是它只在定义它的源文件内有效，其他源文件无法访问它。
   所以，普通全局变量穿上static外衣后，它就变成了新娘，已心有所属，只能被定义它的源文件（新郎）中的变量或函数访问。


   静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0，以后每次调用静态局部变量的时候都用上次调用后的值。
   这个比较好理解，每次函数调用静态局部变量的时候都修改它然后离开，
   下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。
*/



/*
    4. 寄存器变量

    register 声明告诉编译器,它所声明的变量在程序中使用频率较高。其思想是,将 register 变量放在机器的寄存器中,
    这样可以使程序更小、执行速度更快。但编译器可以 忽略此选项。

    register 声明只适用于自动变量以及函数的形式参数。

    if (register unsigned m, register long n) {
        register int i; ...
    }

    实际使用时,底层硬件环境的实际情况对寄存器变量的使用会有一些限制。
    每个函数中 只有很少的变量可以保存在寄存器中,且只允许某些类型的变量。

    但是,过量的寄存器声明 并没有什么害处,这是因为编译器可以忽略过量的或不支持的寄存器变量声明。
    另外,无论 寄存器变量实际上是不是存放在寄存器中,它的地址都是不能访问的

    在不同的机器中,对寄存器变量的数目和类型的具体限制也 是不同的。
*/



/*
    5. 初始化

    在不进行显式初始化的情况下,外部变量和静态变量都将被初始化为 0,
    而自动变量和寄 存器变量的初值则没有定义(即初值为无用的信息)。


    数组的初始化：

    int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    当省略数组的长度时,编译器将把花括号中初始化表达式的个数作为数组的长度,在本例中 数组的长度为 12。



    字符数组的初始化比较特殊:可以用一个字符串来代替用花括号括起来并用逗号分隔的 初始化表达式序列。例如:
    char pattern[] = "ould ";
    它同下面的声明是等价的:
    char pattern[] = { 'o', 'u', 'l', 'd'}; 这种情况下,数组的长度是 5(4 个字符加上一个字符串结束符'\0')。
*/


/* 6. C 预处理器

   C 语言通过预处理器提供了一些语言功能。从概念上讲,预处理器是编译过程中单独执行 的第一个步骤。
   两个最常用的预处理器指令是:#include 指令(用于在编译期间把指定文 件的内容包含进当前文件中)和
   #define 指令(用任意字符序列替代一个标记)。本节还将介 绍预处理器的其它一些特性,如条件编译与带参数的宏。
*/



/* 7. 文件包含

   文件包含指令(即#include 指令)使得处理大量的#define 指令以及声明更加方便。
   在源文件中,任何形如:
   #include "文件名"
   或
   #include <文件名>
   的行都将被替换为由文件名指定的文件的内容。如果文件名用引号引起来,则在源文件所在 位置查找该文件;
   如果在该位置没有找到文件,或者如果文件名是用尖括号<与>括起来的, 则将根据相应的规则查找该文件,
   这个规则同具体的实现有关。被包含的文件本身也可包含 #include 指令。

   源文件的开始处通常都会有多个#include 指令,它们用以包含常见的#define 语句和 extern 声明,或
   从头文件中访问库函数的函数原型声明,比如<stdio.h>。
   (严格地说,这 些内容没有必要单独存放在文件中;访问头文件的细节同具体的实现有关。)
   在大的程序中,#include 指令是将所有声明捆绑在一起的较好的方法。
   它保证所有的 源文件都具有相同的定义与变量声明,这样可以避免出现一些不必要的错误。
   很自然,如果 某个包含文件的内容发生了变化,那么所有依赖于该包含文件的源文件都必须重新编译。
*/



/* 8.宏替换

   #define 名字 替换文本
   宏定义的形式如下:
   #define 名字 替换文本
   这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。 #define 指令中的名字与变量名的命名方式相同,替换文本可以是任意字符串。通常情况下, #define 指令占一行,替换文本是#define 指令行尾部的所有剩余部分内容,但也可以把一 个较长的宏定义分成若干行,这时需要在待续的行末尾加上一个反斜杠符\。#define 指令 定义的名字的作用域从其定义点开始,到被编译的源文件的末尾处结束。宏定义中也可以使 用前面出现的宏定义。替换只对记号进行,对括在引号中的字符串不起作用。例如,如果 YES 是一个通过#define 指令定义过的名字,则在 printf("YES")或 YESMAN 中将不执行替换。
   替换文本可以是任意的,例如:
   #define forever for (;;)
   该语句为无限循环定义了一个新名字 forever。
   宏定义也可以带参数,这样可以对不同的宏调用使用不同的替换文本。例如,下列宏定 义定义了一个宏 max:
   #define max(A, B) ((A) > (B) ? (A) : (B))
   使用宏 max 看起来很像是函数词用,但宏调用直接将替换文本插入到代码中。形式参数(在
   此为 A 或 B)的每次出现都将被替换成对应的实际参数。因此,语句: x = max(p+q, r+s);
   将被替换为下列形式:
   x = ((p+q) > (r+s) ? (p+q) : (r+s));
   如果对各种类型的参数的处理是一致的,则可以将同一个宏定义应用于任何数据类型, 而无需针对不同的数据类型需要定义不同的 max 函数。


   将被替换为下列形式:
   x = ((p+q) > (r+s) ? (p+q) : (r+s));
   如果对各种类型的参数的处理是一致的,则可以将同一个宏定义应用于任何数据类型, 而无需针对不同的数据类型需要定义不同的 max 函数。
   仔细考虑一下 max 的展开式,就会发现它存在一些缺陷。其中,作为参数的表达式要重 复计算两次,如果表达式存在副作用(比如含有自增运算符或输入/输出),则会出现不正确 的情况。例如:
   max(i++, j++)
   它将对每个参数执行两次自增操作。同时还必须注意,要适当使用圆括号以保证计算次序的 正确性。考虑下列宏定义:
   #define square(x) x * x
   当用 squrare(z+1)调用该宏定义时会出现什么情况呢?
   但是,宏还是很有价值的。<stdio.h>头文件中有一个很实用的例子:getchar 与 putchar 函数在实际中常常被定义为宏,这样可以避免处理字符时调用函数所需的运行时开 销。<ctype.h>头文件中定义的函数也常常是通过宏实现的。
   可以通过#undef 指令取消名字的宏定义,这样做可以保证后续的调用是函数调用,而不 是宏调用:
   #undef getchar
   int getchar(void) { ... }
   形式参数不能用带引号的字符串替换。但是,如果在替换文本中,参数名以#作为前缀则 结果将被扩展为由实际参数替换该参数的带引号的字符串。例如,可以将它与字符串连接运 算结合起来编写一个调试打印宏:
   #define dprint(expr) printf(#expr " = %g\n", expr)
   使用语句
   dprint(x/y)
   调用该宏时,该宏将被扩展为:
   printf("x/y" " = &g\n", x/y);
   其中的字符串被连接起来了,这样,该宏调用的效果等价于
   printf("x/y = &g\n", x/y); 在实际参数中,每个双引号"将被替换为\",反斜杠\将被替换为\\,因此替换后的字符串是
   合法的字符串常量。
   预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与 ##相邻,则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新 扫描。例如,下面定义的宏 paste 用于连接两个参数
   #define paste(front, back) front ## back 因此,宏调用paste(name, 1)的结果将建立记号name1。



   ******* 可以通过#undef 指令取消名字的宏定义,这样做可以保证后续的调用是函数调用,而不是宏调用
   #define getchar
   #undef getchar


   形式参数不能用带引号的字符串替换,。但是,如果在替换文本中,参数名以#作为前缀则 结果将被扩展为由实际参数替换该参数的带引号的字符串。
   例如,可以将它与字符串连接运 算结合起来编写一个调试打印宏:
   #define dprint(expr) printf(#expr " = %2.1f\n", expr)
   == printf("x/y" " = %2.1f\n", x/y);



   预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与 ##相邻,
   则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新 扫描。
   例如,下面定义的宏 paste 用于连接两个参数

   #define paste(front, back) front ## back 因此,宏调用paste(name, 1)的结果将建立记号name1。
*/



/* 9. 条件包含

   还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程 中进行计算。
   这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了 一种手段。

   #if 语句对其中的常量表达式（其中不能包括sizeof，类型转换运算符，或enum常量进行求值。
   若该表达式的值不等于 0, 则包含其后的各行，直到遇到#endif、#elif 或 #else 语句为止
   (预处理器语句#elif 类似于 else if)。

   在#if 语句中可以使用表达式 defined(名字),该表达式的值遵循下列规则:当名字已经定义时,其值为 1;
   否则,其值 为0。

   例如：
   为了保证hdr.h文件的内容只被包含一次，可以将该文件的内容包含在下列形式 的条件语句中:
   #if !defined(HRD)
   # define HRD
    ... hdr.h 文件的内容放在这里
   #endif

   第一次包含头文件 hdr.h 时,将定义名字 HDR;此后再次包含该头文件时,会发现该名字已 经定义,
   这样将直接跳转到#endif 处。类似的方式也可以用来避免多次重复包含同一文件。

   如果多个头文件能够一致地使用这种方式,那么,每个头文件都可以将它所依赖的任何头文件包含进来,
   用户不必考虑和处理头文件之间的各种依赖关系。

   下面的这段预处理代码首先测试系统变量 SYSTEM,然后根据该变量的值确定包含哪个版 本的头文件:

    #if SYSTEM == SYSV
        #define HRD "sysv.h"
    #elif SYSTEM == BSD
        #define HRD "bsd.h"
    #elif SYSTEM == MSDOS
        #define HRD "msdos.h"
    #else
        #define HRD "default.h"
    #endif

    #include HRD



    C 语言专门定义了两个预处理语句#ifdef 与#ifndef,它们用来测试某个名字是否已经 定义。
    上面有关#if 的第一个例子可以改写为下列形式:

    #ifndef HDR
    #define EDR
    // hdr.h 文件的内容放在这里
    #endif
*/

#include <stdio.h>

// 必须使用圆括号保证执行顺序
#define max(A, B) ((A) > (B) ? (A) : (B))
#define dprint(expr) printf(#expr " = %2.1f\n", expr)
#define paste(front, back) front ## back

#if SYSTEM == SYSV
    #define HRD "sysv.h"
#elif SYSTEM == BSD
    #define HRD "bsd.h"
#elif SYSTEM == MSDOS
    #define HRD "msdos.h"
#else
    #define HRD "default.h"
#endif

#include HRD

#ifndef HDR
    #define HDR "hello"
#endif

const static int unix = 3;

main() {

    printf("%3d \n", max(3, 5));
    dprint(5 / 10);
    printf("%d \n", paste(1, 3));
    return 0;
}

#undef max(A, B)
#undef dprint(expr)
#undef paste(front, back)